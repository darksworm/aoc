package ijb.adventofcode.day5

import java.io.File
import java.util.*
import kotlin.collections.HashMap

fun read(filePath: String): Pair<String, String> {
    val content = File(filePath).readText(Charsets.UTF_8).trim()

    val split = content.split("\n\n")

    assert(split.size == 2)

    return Pair(split[0], split[1])
}

fun rulesToMap(rules: String): Map<Int, List<Int>> {
    val result = mutableMapOf<Int, MutableList<Int>>()

    rules
        .split("\n")
        .map {
            it.split("|").map(String::toInt)
        }
        .forEach {
            if (!result.containsKey(it[0])) {
                result[it[0]] = mutableListOf(it[1])
            } else {
                result[it[0]]!!.add(it[1])
            }
        }

    return result
}

fun updatesToList(updates: String): List<Array<Int>> {
    return updates
            .split("\n")
            .map{
                it.split(",").map(String::toInt).toTypedArray()
            }
}

fun isValidUpdate(ruleMap: Map<Int, List<Int>>, update: Array<Int>): Boolean {
    update.forEachIndexed { index, value ->
        val cannotPrecedeList = ruleMap[value]

        assert(cannotPrecedeList != null)

        if (index == 0) {
            return@forEachIndexed
        }

        update
            .copyOfRange(0, index - 1)
            .forEach { subsequentValue ->
                if (cannotPrecedeList!!.firstOrNull{ it == subsequentValue } != null) {
                    return@isValidUpdate false
                }
            }
    }

    return true;
}

fun partOne(filePath: String): Int {
    val (rules, updates) = read(filePath)

    val ruleMap = rulesToMap(rules)
    val updatesList = updatesToList(updates)

    return updatesList
        .filter {
            isValidUpdate(ruleMap, it)
        }
        .sumOf {
            assert(it.size % 2 == 0)
            it[it.size / 2]
        }
}

/** way to cheat. this method was generated by chatGPT */
fun topologicalSort(graph: Map<Int, List<Int>>, nodes: Set<Int>): List<Int> {
    // Initialize in-degree of each node to 0
    val inDegree = HashMap<Int, Int>()
    for (node in nodes) {
        inDegree[node] = 0
    }

    // Compute in-degree based on edges
    for ((_, neighbors) in graph) {
        for (v in neighbors) {
            if (v in nodes) {
                inDegree[v] = inDegree.getOrDefault(v, 0) + 1
            }
        }
    }

    // Initialize queue with nodes having in-degree 0
    val queue: Queue<Int> = LinkedList()
    for ((node, degree) in inDegree) {
        if (degree == 0) {
            queue.add(node)
        }
    }

    val sortedList = mutableListOf<Int>()

    while (queue.isNotEmpty()) {
        val current = queue.remove()
        sortedList.add(current)

        for (neighbor in graph.getOrDefault(current, emptyList())) {
            if (neighbor in nodes) {
                inDegree[neighbor] = inDegree[neighbor]!! - 1
                if (inDegree[neighbor] == 0) {
                    queue.add(neighbor)
                }
            }
        }
    }

    if (sortedList.size != nodes.size) {
        throw IllegalArgumentException("Cycle detected or incomplete ordering.")
    }

    return sortedList
}

/** way to cheat. this method was generated by chatGPT */
fun reorderUpdate(ruleMap: Map<Int, List<Int>>, update: Array<Int>): Array<Int> {
    // way to cheat. this method was generated by chatGPT
    val updateSet = update.toHashSet()
    val subGraph = HashMap<Int, List<Int>>()

    for ((beforeValue, valuesAfter) in ruleMap) {
        if (beforeValue in updateSet) {
            val filteredValues = valuesAfter.filter { it in updateSet }
            if (filteredValues.isNotEmpty()) {
                subGraph[beforeValue] = filteredValues
            }
        }
    }

    return topologicalSort(subGraph, updateSet).toTypedArray()
}

fun partTwo(filePath: String): Int {
    val (rules, updates) = read(filePath)

    val ruleMap = rulesToMap(rules)
    val updatesList = updatesToList(updates)

    return updatesList
        .filterNot {
            isValidUpdate(ruleMap, it)
        }
        .map {
            reorderUpdate(ruleMap, it)
        }
        .sumOf {
            assert(it.size % 2 == 0)
            it[it.size / 2]
        }
}

fun main() {
    val file = "./src/main/kotlin/ijb/adventofcode/day5/input.txt"

    println("Part one result is: ${partOne(file)}")
    println("Part two result is: ${partTwo(file)}")
}
